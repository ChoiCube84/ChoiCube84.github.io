---
layout: post
title: "백준 1067번"
subtitle: "이진 검색 트리"
date: 2023-08-24 18:32:00+0900
background: '/img/posts/2023/problem_solving/problem_solving.png'
katex: true
category: Study
tags: [ problem_solving ]
---

# 백준 1067번

오늘 풀어본 문제는 백준의 1067번 문제<sup>[1](#footnote_1)</sup>이다. 문제 풀이에 사용한 언어는 C++ 이다.

## solved.ac 기준 CLASS

<img src="https://static.solved.ac/class/c8.svg" width="50%" height="50%" alt="CLASS 8">

## 문제 정보

이 문제의 내용과 조건은 다음과 같다.

### 문제

$N$ 개의 수가 있는 $X$ 와 $Y$ 가 있다. 이때 $X$ 나 $Y$ 를 순환 이동시킬 수 있다. 순환 이동이란 마지막 원소를 제거하고 그 수를 맨 앞으로 다시 삽입하는 것을 말한다. 예를 들어, $\{1, 2, 3\}$ 을 순환 이동시키면 $\{3, 1, 2\}$ 가 될 것이고, $\{3, 1, 2\}$ 는 $\{2, 3, 1\}$ 이 된다. 순환 이동은 $0$ 번 또는 그 이상 할 수 있다. 이 모든 순환 이동을 한 후에 점수를 구하면 된다. 점수 $S$ 는 다음과 같이 구한다.

$S = X[0] \times Y[0] + X[1] \times Y[1] + \cdots + X[N-1] \times Y[N-1]$

이때 $S$ 를 최대로 하면 된다. 

### 입력

첫째 줄에 $N$ 이 주어진다. 둘째 줄에는 $X$ 에 들어있는 $N$ 개의 수가 주어진다. 셋째 줄에는 $Y$ 에 있는 수가 모두 주어진다. $N$ 은 $60,000$ 보다 작거나 같은 자연수이고, $X$ 와 $Y$ 에 들어있는 모든 수는 $100$ 보다 작은 자연수 또는 $0$ 이다.

### 출력

첫째 줄에 $S$ 의 최댓값을 출력한다.

## 풀이과정

### 1번째 시도

이 문제는 FFT를 이용해야 하는 문제이다. 정확하게 말하자면, (작성중)

코드는 다음과 같이 작성하였다.

```cpp
#include <bits/stdc++.h>

using namespace std;

double const_pi(void) {
	return std::atan(1) * 4;
}

void FFT(std::vector<std::complex<double>>& a, const std::complex<double>& w) {
	int n = a.size();
	if (n == 1) return;

	std::vector<std::complex<double>> a_even(n / 2), a_odd(n / 2);
	for (int i = 0; i < n / 2; i++) {
		a_even[i] = a[2 * i];
		a_odd[i] = a[2 * i + 1];
	}

	std::complex<double> w_sq = w * w;
	FFT(a_even, w_sq);
	FFT(a_odd, w_sq);

	std::complex<double> w_i = 1;
	for (int i = 0; i < n / 2; i++) {
		a[i] = a_even[i] + w_i * a_odd[i];
		a[i + n / 2] = a_even[i] - w_i * a_odd[i];
		w_i *= w;
	}
}

std::vector<std::complex<double>> convolution(std::vector<std::complex<double>> a, std::vector<std::complex<double>> b, bool getIntegerResult = false) {
	int n = 1;
	double pi = const_pi();

	while (n <= a.size() || n <= b.size()) {
		n <<= 1;
	}
	n <<= 1;

	a.resize(n);
	b.resize(n);

	std::vector<std::complex<double>> c(n);

	std::complex<double> w(cos(2 * pi / n), sin(2 * pi / n));

	FFT(a, w);
	FFT(b, w);

	for (int i = 0; i < n; i++) {
		c[i] = a[i] * b[i];
	}

	FFT(c, std::complex(w.real(), -w.imag()));

	for (int i = 0; i < n; i++) {
		c[i] /= std::complex<double>(n, 0);
		if (getIntegerResult) {
			c[i] = std::complex(round(c[i].real()), round(c[i].imag()));
		}
	}

	return c;
}

int main(void) {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	int N;
	cin >> N;

	vector<complex<double>> X(2 * N);
	vector<complex<double>> Y(N);

	for (int i = 0; i < N; i++) {
		int tempNum;
		cin >> tempNum;
		X[i] = X[i + N] = complex<double>(tempNum, 0);
	}

	for (int i = 0; i < N; i++) {
		int tempNum;
		cin >> tempNum;
		Y[N - i - 1] = complex<double>(tempNum, 0);
	}

	auto Z = convolution(X, Y, true);

	int result = 0;

	for (auto& i : Z) {
		cout << i << " ";
		result = max(result, static_cast<int>(i.real()));
	}
	cout << endl;
	cout << result;

	return 0;
}
```

실행 결과 '출력 초과'가 나왔다.

### 2번째 시도

(작성중)

코드는 다음과 같이 작성하였다.

```cpp
#include <bits/stdc++.h>

using namespace std;

double const_pi(void) {
	return std::atan(1) * 4;
}

void FFT(std::vector<std::complex<double>>& a, const std::complex<double>& w) {
	int n = a.size();
	if (n == 1) return;

	std::vector<std::complex<double>> a_even(n / 2), a_odd(n / 2);
	for (int i = 0; i < n / 2; i++) {
		a_even[i] = a[2 * i];
		a_odd[i] = a[2 * i + 1];
	}

	std::complex<double> w_sq = w * w;
	FFT(a_even, w_sq);
	FFT(a_odd, w_sq);

	std::complex<double> w_i = 1;
	for (int i = 0; i < n / 2; i++) {
		a[i] = a_even[i] + w_i * a_odd[i];
		a[i + n / 2] = a_even[i] - w_i * a_odd[i];
		w_i *= w;
	}
}

std::vector<std::complex<double>> convolution(std::vector<std::complex<double>> a, std::vector<std::complex<double>> b, bool getIntegerResult = false) {
	int n = 1;
	double pi = const_pi();

	while (n <= a.size() || n <= b.size()) {
		n <<= 1;
	}
	n <<= 1;

	a.resize(n);
	b.resize(n);

	std::vector<std::complex<double>> c(n);

	std::complex<double> w(cos(2 * pi / n), sin(2 * pi / n));

	FFT(a, w);
	FFT(b, w);

	for (int i = 0; i < n; i++) {
		c[i] = a[i] * b[i];
	}

	FFT(c, std::complex(w.real(), -w.imag()));

	for (int i = 0; i < n; i++) {
		c[i] /= std::complex<double>(n, 0);
		if (getIntegerResult) {
			c[i] = std::complex(round(c[i].real()), round(c[i].imag()));
		}
	}

	return c;
}

int main(void) {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	int N;
	cin >> N;

	vector<complex<double>> X(2 * N);
	vector<complex<double>> Y(N);

	for (int i = 0; i < N; i++) {
		int tempNum;
		cin >> tempNum;
		X[i] = X[i + N] = complex<double>(tempNum, 0);
	}

	for (int i = 0; i < N; i++) {
		int tempNum;
		cin >> tempNum;
		Y[N - i - 1] = complex<double>(tempNum, 0);
	}

	auto Z = convolution(X, Y, true);

	int result = 0;

	for (auto& i : Z) {
		result = max(result, static_cast<int>(i.real()));
	}

	cout << result;

	return 0;
}
```

그러자 모든 테스트 케이스를 통과하고 정답이 나오는 것을 확인할 수 있었다.

## 마무리

(작성중)

오늘의 PS는 여기까지!

---
<a name="footnote_1">1</a>: <https://www.acmicpc.net/problem/1067>  
<a name="footnote_2">2</a>: <https://github.com/ChoiCube84/baekjoon-solutions/blob/main/C%2B%2B/custom_data_structures/fast_fourier_transform.hpp>  