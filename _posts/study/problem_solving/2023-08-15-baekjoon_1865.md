---
layout: post
title: "ë°±ì¤€ 1865ë²ˆ"
subtitle: "ì›œí™€"
date: 2023-08-15 23:51:00+0900
background: '/img/posts/2023/problem_solving/problem_solving.png'
katex: true
category: Study
tags: [ problem_solving ]
---

# ë°±ì¤€ 1865ë²ˆ

ì˜¤ëŠ˜ í’€ì–´ë³¸ ë¬¸ì œëŠ” ë°±ì¤€ì˜ 1865ë²ˆ ë¬¸ì œ<sup>[1](#footnote_1)</sup>ì´ë‹¤. ë¬¸ì œ í’€ì´ì— ì‚¬ìš©í•œ ì–¸ì–´ëŠ” C++ ì´ë‹¤.

## solved.ac ê¸°ì¤€ CLASS

<img src="https://static.solved.ac/class/c4.svg" width="50%" height="50%" alt="CLASS 4">

## ë¬¸ì œ ì •ë³´

ì´ ë¬¸ì œì˜ ë‚´ìš©ê³¼ ì¡°ê±´ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

### ë¬¸ì œ

ë•ŒëŠ” 2020ë…„, ë°±ì¤€ì´ëŠ” ì›”ë“œë‚˜ë¼ì˜ í•œ êµ­ë¯¼ì´ë‹¤. ì›”ë“œë‚˜ë¼ì—ëŠ” $N$ê°œì˜ ì§€ì ì´ ìˆê³  Nê°œì˜ ì§€ì  ì‚¬ì´ì—ëŠ” Mê°œì˜ ë„ë¡œì™€ Wê°œì˜ ì›œí™€ì´ ìˆë‹¤. (ë‹¨ ë„ë¡œëŠ” ë°©í–¥ì´ ì—†ìœ¼ë©° ì›œí™€ì€ ë°©í–¥ì´ ìˆë‹¤.) ì›œí™€ì€ ì‹œì‘ ìœ„ì¹˜ì—ì„œ ë„ì°© ìœ„ì¹˜ë¡œ ê°€ëŠ” í•˜ë‚˜ì˜ ê²½ë¡œì¸ë°, íŠ¹ì´í•˜ê²Œë„ ë„ì°©ì„ í•˜ê²Œ ë˜ë©´ ì‹œì‘ì„ í•˜ì˜€ì„ ë•Œë³´ë‹¤ ì‹œê°„ì´ ë’¤ë¡œ ê°€ê²Œ ëœë‹¤. ì›œí™€ ë‚´ì—ì„œëŠ” ì‹œê³„ê°€ ê±°ê¾¸ë¡œ ê°„ë‹¤ê³  ìƒê°í•˜ì—¬ë„ ì¢‹ë‹¤.

ì‹œê°„ ì—¬í–‰ì„ ë§¤ìš° ì¢‹ì•„í•˜ëŠ” ë°±ì¤€ì´ëŠ” í•œ ê°€ì§€ ê¶ê¸ˆì¦ì— ë¹ ì¡Œë‹¤. í•œ ì§€ì ì—ì„œ ì¶œë°œì„ í•˜ì—¬ì„œ ì‹œê°„ì—¬í–‰ì„ í•˜ê¸° ì‹œì‘í•˜ì—¬ ë‹¤ì‹œ ì¶œë°œì„ í•˜ì˜€ë˜ ìœ„ì¹˜ë¡œ ëŒì•„ì™”ì„ ë•Œ, ì¶œë°œì„ í•˜ì˜€ì„ ë•Œë³´ë‹¤ ì‹œê°„ì´ ë˜ëŒì•„ê°€ ìˆëŠ” ê²½ìš°ê°€ ìˆëŠ”ì§€ ì—†ëŠ”ì§€ ê¶ê¸ˆí•´ì¡Œë‹¤. ì—¬ëŸ¬ë¶„ì€ ë°±ì¤€ì´ë¥¼ ë„ì™€ ì´ëŸ° ì¼ì´ ê°€ëŠ¥í•œì§€ ë¶ˆê°€ëŠ¥í•œì§€ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì—¬ë¼.

### ì…ë ¥

ì²« ë²ˆì§¸ ì¤„ì—ëŠ” í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ì˜ ê°œìˆ˜ $TC$ $(1 \leq TC \leq 5)$ ê°€ ì£¼ì–´ì§„ë‹¤. ê·¸ë¦¬ê³  ë‘ ë²ˆì§¸ ì¤„ë¶€í„° $TC$ ê°œì˜ í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ê°€ ì°¨ë¡€ë¡œ ì£¼ì–´ì§€ëŠ”ë° ê° í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ì˜ ì²« ë²ˆì§¸ ì¤„ì—ëŠ” ì§€ì ì˜ ìˆ˜ $N$ $(1 \leq N \leq 500)$, ë„ë¡œì˜ ê°œìˆ˜ $M$ $(1 \leq M \leq 2500)$, ì›œí™€ì˜ ê°œìˆ˜ $W$ $(1 \leq W \leq 200)$ ì´ ì£¼ì–´ì§„ë‹¤. ê·¸ë¦¬ê³  ë‘ ë²ˆì§¸ ì¤„ë¶€í„° $M+1$ ë²ˆì§¸ ì¤„ì— ë„ë¡œì˜ ì •ë³´ê°€ ì£¼ì–´ì§€ëŠ”ë° ê° ë„ë¡œì˜ ì •ë³´ëŠ” $S$, $E$, $T$ ì„¸ ì •ìˆ˜ë¡œ ì£¼ì–´ì§„ë‹¤. $S$ ì™€ $E$ ëŠ” ì—°ê²°ëœ ì§€ì ì˜ ë²ˆí˜¸, $T$ëŠ” ì´ ë„ë¡œë¥¼ í†µí•´ ì´ë™í•˜ëŠ”ë° ê±¸ë¦¬ëŠ” ì‹œê°„ì„ ì˜ë¯¸í•œë‹¤. ê·¸ë¦¬ê³  $M+2$ ë²ˆì§¸ ì¤„ë¶€í„° $M+W+1$ ë²ˆì§¸ ì¤„ê¹Œì§€ ì›œí™€ì˜ ì •ë³´ê°€ $S$, $E$, $T$ ì„¸ ì •ìˆ˜ë¡œ ì£¼ì–´ì§€ëŠ”ë° $S$ ëŠ” ì‹œì‘ ì§€ì , $E$ëŠ”  ë„ì°© ì§€ì , $T$ ëŠ” ì¤„ì–´ë“œëŠ” ì‹œê°„ì„ ì˜ë¯¸í•œë‹¤. $T$ ëŠ” $10,000$ ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì€ ìì—°ìˆ˜ ë˜ëŠ” $0$ì´ë‹¤.

ë‘ ì§€ì ì„ ì—°ê²°í•˜ëŠ” ë„ë¡œê°€ í•œ ê°œë³´ë‹¤ ë§ì„ ìˆ˜ë„ ìˆë‹¤. ì§€ì ì˜ ë²ˆí˜¸ëŠ” $1$ ë¶€í„° $N$ ê¹Œì§€ ìì—°ìˆ˜ë¡œ ì¤‘ë³µ ì—†ì´ ë§¤ê²¨ì ¸ ìˆë‹¤.

### ì¶œë ¥

$TC$ ê°œì˜ ì¤„ì— ê±¸ì³ì„œ ë§Œì•½ì— ì‹œê°„ì´ ì¤„ì–´ë“¤ë©´ì„œ ì¶œë°œ ìœ„ì¹˜ë¡œ ëŒì•„ì˜¤ëŠ” ê²ƒì´ ê°€ëŠ¥í•˜ë©´ YES, ë¶ˆê°€ëŠ¥í•˜ë©´ NOë¥¼ ì¶œë ¥í•œë‹¤.

## í’€ì´ê³¼ì •

### 0ë²ˆì§¸ ì‹œë„

<details>
<summary></summary>

ì‚¬ì‹¤ ì´ê±¸ ì‹œë„ë¡œ ì³ì•¼í• ì§€ ì• ë§¤í•˜ê¸´ í•˜ì§€ë§Œ, ì—„ì—°íˆ ì œì¶œ ê¸°ë¡ì— ë‚¨ì•„ìˆëŠ” ì‹œë„ì´ê¸° ë•Œë¬¸ì— ê°„ë‹¨í•˜ê²Œ ì–¸ê¸‰ë§Œí•˜ê³  ë„˜ì–´ê°€ê² ë‹¤. <br> <br>

ë‚´ê°€ PSë¥¼ í•  ë•ŒëŠ” ë‹¨ìˆœíˆ í•œ ë¬¸ì œë§Œ í’€ì–´ì„œ ì˜¬ë¦¬ê³  ë§ˆëŠ”ê²Œ ì•„ë‹ˆê³ , ì—¬ëŸ¬ ê°€ì§€ ë¬¸ì œë¥¼ í‘¼ ë‹¤ìŒì— íŠ¹íˆ ì–´ë ¤ì› ê±°ë‚˜ ì¸ìƒê¹Šì—ˆë˜ ë¬¸ì œë“¤ì— ëŒ€í•˜ì—¬ ì˜¬ë¦¬ëŠ” í¸ì´ë‹¤. ì˜¤ëŠ˜ë„ ë§ˆì°¬ê°€ì§€ì˜€ì§€ë§Œ, ë‹¤ë¥¸ ë‚ ì—ëŠ” í•œ ì ì´ ì—†ë˜ ì–´ì²˜êµ¬ë‹ˆ ì—†ëŠ” ì‹¤ìˆ˜ë¥¼ í–ˆë‹¤. <br> <br>

ì „í˜€ ë‹¤ë¥¸ ë¬¸ì œì˜ ì½”ë“œë¥¼ ì´ ë¬¸ì œì˜ ì œì¶œì— ë„£ì–´ë²„ë¦° ê²ƒì´ë‹¤! ë§í•  ê²ƒë„ ì—†ì´ 'í‹€ë ¸ìŠµë‹ˆë‹¤' ê°€ ë–´ê³ , ê·¸ ì™€ì¤‘ì— ì›ë˜ ë¬¸ì œì—ì„œë„ í‹€ë ¸ë‹¤. (...) ì–´ì¨Œë“  0ë²ˆì§¸ ì‹œë„ì— ëŒ€í•œ ì´ì•¼ê¸°ëŠ” ì—¬ê¸°ê¹Œì§€ë§Œ í•˜ê² ë‹¤. ê¼­ í•„ìš”í•œ ë‚´ìš©ì€ ì•„ë‹ˆì§€ë§Œ ì œì¶œ ê¸°ë¡ì„ ì—´ì‹¬íˆ ì°¾ì•„ë³´ëŠ” ì‚¬ëŒì´ ìˆì„ê¹Œ í•˜ì—¬ ì ‘ì€ ìƒíƒœë¡œ ë‚¨ê²¨ë‘ê² ë‹¤. <br> <br>

</details>

### 1ë²ˆì§¸ ì‹œë„

ì´ ë¬¸ì œëŠ” ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•´ì•¼í•˜ëŠ” ë¬¸ì œì´ë‹¤. ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜ì€ ì—¬ëŸ¬ ê°€ì§€ ê·¸ë˜í”„ ìµœë‹¨ê±°ë¦¬ ê²½ë¡œ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ ì¤‘ í•˜ë‚˜ì¸ë°, ê·¸ë˜í”„ì— ìŒìˆ˜ ê°„ì„ ì´ ì¡´ì¬í•  ë•Œ ì£¼ë¡œ ì“°ì´ë©°, ìŒìˆ˜ ê°„ì„ ìœ¼ë¡œ ì´ë£¨ì–´ì§„ 'ì‚¬ì´í´' ì´ ì¡´ì¬í•˜ëŠ” ì§€ë„ ì•Œê³ ë¦¬ì¦˜ì—ì„œ ì•Œì•„ë‚¼ ìˆ˜ ìˆë‹¤.

ì´ ë¬¸ì œëŠ” ë”±íˆ ì–´ë–¤ ìµœë‹¨ê±°ë¦¬ë¥¼ êµ¬í•˜ë¼ê¸° ë³´ë‹¤ë„, ì‹œì‘ ìœ„ì¹˜ì— ëŒì•„ì™”ì„ ë•Œ ì‹œê°„ì„ ë˜ëŒë¦° ìƒíƒœë¡œ ë„ì°©í•  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ê²ƒì´ ëª©í‘œì´ê¸° ë•Œë¬¸ì— 'ì‚¬ì´í´'ì˜ ì¡´ì¬ ì—¬ë¶€ë¥¼ íŒë‹¨í•˜ëŠ” ê²ƒì´ ë¬¸ì œì—ì„œ ì¤‘ìš”í•œ ì ì´ ëœë‹¤.

ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•˜ì˜€ë‹¤.

```cpp
#include <bits/stdc++.h>

using namespace std;

vector<tuple<int, int, int>> edges;
int shortestPath[501] = { 0, };

int main(void) {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	int TC;
	cin >> TC;

	while (TC--) {
		int N, M, W;
		cin >> N >> M >> W;

		edges.clear();

		for (int i = 0; i < M; i++) {
			int S, E, T;
			cin >> S >> E >> T;

			edges.emplace_back(make_tuple(S, E, T));
			edges.emplace_back(make_tuple(E, S, T));
		}

		for (int i = 0; i < W; i++) {
			int S, E, T;
			cin >> S >> E >> T;

			edges.emplace_back(make_tuple(S, E, -T));
		}

		shortestPath[1] = 0;
		for (int i = 2; i <= N; i++) {
			shortestPath[i] = INT_MAX;
		}

		for (int i = 1; i <= N - 1; i++) {
			for (auto edge : edges) {
				int start = get<0>(edge);
				int end = get<1>(edge);
				int length = get<2>(edge);

				if (shortestPath[start] == INT_MAX) {
					continue;
				}
				else {
					shortestPath[end] = min(shortestPath[end], shortestPath[start] + length);
				}
				
			}
		}
		
		bool negativeCycleExists = false;

		for (auto edge : edges) {
			int start = get<0>(edge);
			int end = get<1>(edge);
			int length = get<2>(edge);

			if (shortestPath[start] == INT_MAX) {
				continue;
			}
			else {
				if (shortestPath[end] > shortestPath[start] + length) {
					negativeCycleExists = true;
					break;
				}
			}
		}

		if (negativeCycleExists) {
			cout << "YES\n";
		}
		else {
			cout << "NO\n";
		}
	}

	return 0;
}
```

ì‹¤í–‰ ê²°ê³¼, 'í‹€ë ¸ìŠµë‹ˆë‹¤' ê°€ ë‚˜ì™”ë‹¤.

### 2ë²ˆì§¸ ì‹œë„

ë¶„ëª…íˆ ì•Œê³ ë¦¬ì¦˜ì„ ë§ê²Œ ì ìš©í•œ ê²ƒ ê°™ì€ë°, ë­ê°€ ë¬¸ì œì¸ì§€ ì´í•´í•  ìˆ˜ ì—†ì—ˆë‹¤. ìš°ì„  $N-1$ ë²ˆ ë°˜ë³µí•˜ë˜ê±¸ $N$ ë²ˆ ë°˜ë³µí•˜ë„ë¡ ë°”ê¿”ë³´ëŠ” ì‹œë„ë¥¼ í–ˆê³ , ê·¸ëŒ€ë¡œ ì œì¶œì„ í•´ë³´ì•˜ë‹¤.

ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•˜ì˜€ë‹¤.

```cpp
#include <bits/stdc++.h>

using namespace std;

vector<tuple<int, int, int>> edges;
int shortestPath[501] = { 0, };

int main(void) {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	int TC;
	cin >> TC;

	while (TC--) {
		int N, M, W;
		cin >> N >> M >> W;

		edges.clear();

		for (int i = 0; i < M; i++) {
			int S, E, T;
			cin >> S >> E >> T;

			edges.emplace_back(make_tuple(S, E, T));
			edges.emplace_back(make_tuple(E, S, T));
		}

		for (int i = 0; i < W; i++) {
			int S, E, T;
			cin >> S >> E >> T;

			edges.emplace_back(make_tuple(S, E, -T));
		}

		shortestPath[1] = 0;
		for (int i = 2; i <= N; i++) {
			shortestPath[i] = INT_MAX;
		}

		for (int i = 1; i <= N; i++) {
			for (auto edge : edges) {
				int start = get<0>(edge);
				int end = get<1>(edge);
				int length = get<2>(edge);

				if (shortestPath[start] == INT_MAX) {
					continue;
				}
				else {
					shortestPath[end] = min(shortestPath[end], shortestPath[start] + length);
				}
				
			}
		}
		
		bool negativeCycleExists = false;

		for (auto edge : edges) {
			int start = get<0>(edge);
			int end = get<1>(edge);
			int length = get<2>(edge);

			if (shortestPath[start] == INT_MAX) {
				continue;
			}
			else {
				if (shortestPath[end] > shortestPath[start] + length) {
					negativeCycleExists = true;
					break;
				}
			}
		}

		if (negativeCycleExists) {
			cout << "YES\n";
		}
		else {
			cout << "NO\n";
		}
	}

	return 0;
}
```

ì‹¤í–‰ ê²°ê³¼, 'í‹€ë ¸ìŠµë‹ˆë‹¤' ê°€ ë‚˜ì™”ë‹¤.

### 3ë²ˆì§¸ ì‹œë„

ì´ë²ˆì— ì‹œë„í•´ë³¸ ë°©ë²•ì€ ê°±ì‹ ê³¼ì •ì—ì„œ ë°©ë¬¸í•œ ì ì´ ì—†ëŠ” ë…¸ë“œì¸ì§€ ê²€ì‚¬í•˜ëŠ” ê³¼ì •ì„ ì œì™¸í•˜ì˜€ë‹¤. ì–´ì§œí”¼ ë°©ë¬¸í•œ ì ì´ ì—†ëŠ” ë…¸ë“œì— ëŒ€í•œ ê°±ì‹ ì´ ì¼ì–´ë‚˜ë”ë¼ë„ ì´í›„ì— ë‹¤ë¥¸ ê°’ìœ¼ë¡œ ì œëŒ€ë¡œ ê°±ì‹ ë  ê²ƒì´ë¼ê³  ê¸°ëŒ€í•˜ì˜€ë‹¤.

ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•˜ì˜€ë‹¤.

```cpp
#include <bits/stdc++.h>

using namespace std;

vector<tuple<int, int, int>> edges;
int shortestPath[501] = { 0, };

int main(void) {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	int TC;
	cin >> TC;

	while (TC--) {
		int N, M, W;
		cin >> N >> M >> W;

		edges.clear();

		for (int i = 0; i < M; i++) {
			int S, E, T;
			cin >> S >> E >> T;

			edges.emplace_back(make_tuple(S, E, T));
			edges.emplace_back(make_tuple(E, S, T));
		}

		for (int i = 0; i < W; i++) {
			int S, E, T;
			cin >> S >> E >> T;

			edges.emplace_back(make_tuple(S, E, -T));
		}

		shortestPath[1] = 0;
		for (int i = 2; i <= N; i++) {
			shortestPath[i] = INT_MAX;
		}

		for (int i = 1; i <= N - 1; i++) {
			for (auto edge : edges) {
				int start = get<0>(edge);
				int end = get<1>(edge);
				int length = get<2>(edge);

				shortestPath[end] = min(shortestPath[end], shortestPath[start] + length);
				
			}
		}
		
		bool negativeCycleExists = false;

		for (auto edge : edges) {
			int start = get<0>(edge);
			int end = get<1>(edge);
			int length = get<2>(edge);

			if (shortestPath[start] == INT_MAX) {
				continue;
			}
			else {
				if (shortestPath[end] > shortestPath[start] + length) {
					negativeCycleExists = true;
					break;
				}
			}
		}

		if (negativeCycleExists) {
			cout << "YES\n";
		}
		else {
			cout << "NO\n";
		}
	}

	return 0;
}
```

ì‹¤í–‰ ê²°ê³¼, 'í‹€ë ¸ìŠµë‹ˆë‹¤' ê°€ ë‚˜ì™”ë‹¤.

### 4ë²ˆì§¸ ì‹œë„

ì´ì¯¤ë˜ë‹ˆ ì§€ì¹˜ê¸° ì‹œì‘í–ˆë‹¤. ëŒ€ì²´ ë­ê°€ ë¬¸ì œì¸ì§€ ì´í•´ê°€ ì•ˆë˜ì—ˆê¸° ë•Œë¬¸ì— ì¼ë‹¨ ë‹¤ì‹œ í•œ ë²ˆ ë°˜ë³µë¬¸ì˜ ë°˜ë³µ íšŸìˆ˜ë¥¼ ë°”ê¾¸ì–´ì„œ ì œì¶œí•´ ë³´ì•˜ë‹¤.

ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•˜ì˜€ë‹¤.

```cpp
#include <bits/stdc++.h>

using namespace std;

vector<tuple<int, int, int>> edges;
int shortestPath[501] = { 0, };

int main(void) {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	int TC;
	cin >> TC;

	while (TC--) {
		int N, M, W;
		cin >> N >> M >> W;

		edges.clear();

		for (int i = 0; i < M; i++) {
			int S, E, T;
			cin >> S >> E >> T;

			edges.emplace_back(make_tuple(S, E, T));
			edges.emplace_back(make_tuple(E, S, T));
		}

		for (int i = 0; i < W; i++) {
			int S, E, T;
			cin >> S >> E >> T;

			edges.emplace_back(make_tuple(S, E, -T));
		}

		shortestPath[1] = 0;
		for (int i = 2; i <= N; i++) {
			shortestPath[i] = INT_MAX;
		}

		for (int i = 1; i <= N; i++) {
			for (auto edge : edges) {
				int start = get<0>(edge);
				int end = get<1>(edge);
				int length = get<2>(edge);

				shortestPath[end] = min(shortestPath[end], shortestPath[start] + length);
				
			}
		}
		
		bool negativeCycleExists = false;

		for (auto edge : edges) {
			int start = get<0>(edge);
			int end = get<1>(edge);
			int length = get<2>(edge);

			if (shortestPath[start] == INT_MAX) {
				continue;
			}
			else {
				if (shortestPath[end] > shortestPath[start] + length) {
					negativeCycleExists = true;
					break;
				}
			}
		}

		if (negativeCycleExists) {
			cout << "YES\n";
		}
		else {
			cout << "NO\n";
		}
	}

	return 0;
}
```

ì‹¤í–‰ ê²°ê³¼, 'í‹€ë ¸ìŠµë‹ˆë‹¤' ê°€ ë‚˜ì™”ë‹¤.

### 5ë²ˆì§¸ ì‹œë„

ì½”ë“œë¥¼ ë‹¤ì‹œ ì½ì–´ë³´ë‹ˆ, ë§ˆì§€ë§‰ì— ì‚¬ì´í´ì„ íŒë³„í•˜ëŠ” ê³¼ì •ì—ì„œ ê°±ì‹ ê³¼ì •ì—ì„œ ë°©ë¬¸í•œ ì ì´ ì—†ëŠ” ë…¸ë“œì¸ì§€ë¥¼ ê²€ì‚¬í•˜ê³  ìˆì—ˆë‹¤. ë°˜ë³µë¬¸ ë‚´ë¶€ë§Œ ì œì™¸í•´ì£¼ê³ , ë§ˆì§€ë§‰ì— ê²€ì‚¬ê³¼ì •ì—ì„œëŠ” ì œì™¸í•´ì£¼ì§€ ì•Šì•˜ë˜ ê²ƒì´ë‹¤. ë°˜ë³µë¬¸ íšŸìˆ˜ê°€ ì—­ì‹œ ë¬¸ì œê°€ ì•„ë‹ˆì—ˆë˜ ê²ƒ ê°™ì•„ ì›ë˜ëŒ€ë¡œ ëŒë ¤ë‘ì—ˆë‹¤.

ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•˜ì˜€ë‹¤.

```cpp
#include <bits/stdc++.h>

using namespace std;

vector<tuple<int, int, int>> edges;
int shortestPath[501] = { 0, };

int main(void) {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	int TC;
	cin >> TC;

	while (TC--) {
		int N, M, W;
		cin >> N >> M >> W;

		edges.clear();

		for (int i = 0; i < M; i++) {
			int S, E, T;
			cin >> S >> E >> T;

			edges.emplace_back(make_tuple(S, E, T));
			edges.emplace_back(make_tuple(E, S, T));
		}

		for (int i = 0; i < W; i++) {
			int S, E, T;
			cin >> S >> E >> T;

			edges.emplace_back(make_tuple(S, E, -T));
		}

		shortestPath[1] = 0;
		for (int i = 2; i <= N; i++) {
			shortestPath[i] = INT_MAX;
		}

		for (int i = 1; i <= N - 1; i++) {
			for (auto edge : edges) {
				int start = get<0>(edge);
				int end = get<1>(edge);
				int length = get<2>(edge);

				shortestPath[end] = min(shortestPath[end], shortestPath[start] + length);
				
			}
		}
		
		bool negativeCycleExists = false;

		for (auto edge : edges) {
			int start = get<0>(edge);
			int end = get<1>(edge);
			int length = get<2>(edge);

			if (shortestPath[end] > shortestPath[start] + length) {
				negativeCycleExists = true;
				break;
			}
		}

		if (negativeCycleExists) {
			cout << "YES\n";
		}
		else {
			cout << "NO\n";
		}
	}

	return 0;
}
```

ì‹¤í–‰ ê²°ê³¼, 'í‹€ë ¸ìŠµë‹ˆë‹¤' ê°€ ë‚˜ì™”ë‹¤.

### 6ë²ˆì§¸ ì‹œë„

ê²°êµ­ ë‹¤ì‹œ ì§ˆë¬¸ê²Œì‹œíŒì— ë“¤ì–´ê°€ ê¸€ë“¤ì„ ì¡°ê¸ˆ ë‘˜ëŸ¬ë³´ì•˜ê³ , `INT_MAX` ë¥¼ ì‚¬ìš©í•œ ê²ƒì´ ì›ì¸ì´ë¼ëŠ” ì‚¬ì‹¤ì„ ì•Œê²Œë˜ì—ˆë‹¤. ì ë‹¹íˆ í¬ê³  ì˜¤ë²„í”Œë¡œìš°ê°€ ë‚˜ì§€ ì•ŠëŠ” ìˆ˜ë¡œ ë°”ê¿”ì£¼ì—ˆë‹¤.

ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•˜ì˜€ë‹¤.

```cpp
#include <bits/stdc++.h>

using namespace std;

vector<tuple<int, int, int>> edges;
int shortestPath[501] = { 0, };

int main(void) {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	int TC;
	cin >> TC;

	while (TC--) {
		int N, M, W;
		cin >> N >> M >> W;

		edges.clear();

		for (int i = 0; i < M; i++) {
			int S, E, T;
			cin >> S >> E >> T;

			edges.emplace_back(make_tuple(S, E, T));
			edges.emplace_back(make_tuple(E, S, T));
		}

		for (int i = 0; i < W; i++) {
			int S, E, T;
			cin >> S >> E >> T;

			edges.emplace_back(make_tuple(S, E, -T));
		}

		shortestPath[1] = 0;
		for (int i = 2; i <= N; i++) {
			shortestPath[i] = 1000000;
		}

		for (int i = 1; i < N; i++) {
			for (auto edge : edges) {
				int start = get<0>(edge);
				int end = get<1>(edge);
				int length = get<2>(edge);

				shortestPath[end] = min(shortestPath[end], shortestPath[start] + length);
			}
		}
		
		bool negativeCycleExists = false;

		for (auto edge : edges) {
			int start = get<0>(edge);
			int end = get<1>(edge);
			int length = get<2>(edge);

			if (shortestPath[end] > shortestPath[start] + length) {
				negativeCycleExists = true;
				break;
			}
		}

		if (negativeCycleExists) {
			cout << "YES\n";
		}
		else {
			cout << "NO\n";
		}
	}

	return 0;
}
```

ê·¸ëŸ¬ì ë“œë””ì–´! ëª¨ë“  í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë¥¼ í†µê³¼í•˜ê³  ì •ë‹µì´ ë‚˜ì˜¤ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆì—ˆë‹¤.

## ë§ˆë¬´ë¦¬

ì˜¤ëŠ˜ ë¬¸ì œ í’€ì´ ê³¼ì •ì€ ë¬´ì–¸ê°€ ì´ìƒí–ˆë‹¤. ë¬¸ì œì˜ ì›ì¸ì„ ì˜¤ë«ë™ì•ˆ ì§„ë‹¨í•˜ê³  ì‹ ì¤‘í•˜ê²Œ ì½”ë“œë¥¼ ì œì¶œí•˜ì§€ ì•Šê³ , ê·¸ë•Œê·¸ë•Œ ë  ê²ƒ ê°™ì€ ë°©ë²•ë§Œ ìƒê°í•´ì„œ ì„±ê¸‰í•˜ê²Œ í–ˆë˜ ê²ƒì´ë‹¤.

ì•ìœ¼ë¡œëŠ” í›¨ì”¬ ì–´ë ¤ìš´ ë¬¸ì œë“¤ë„ ë§ì´ ë‚˜ì˜¬ ê²ƒì´ê³ , ë” ì–µìš¸í•œ ì¼ë„ ë§ì´ ë‹¹í•  í…ë°, ì´ëŒ€ë¡œëŠ” ì•ˆë˜ê² ë‹¤ëŠ” ìƒê°ì´ ë“¤ì—ˆë‹¤. ì˜¤ëŠ˜ì˜ ê³ ìƒì„ êµí›ˆ ì‚¼ì•„ ë‹¤ë¥¸ ë¬¸ì œë“¤ì„ í’€ ë•ŒëŠ” ë” ì¹¨ì°©í•˜ê³  ì‹ ì¤‘í•˜ê²Œ í’€ì–´ì•¼ê² ë‹¤.

ê·¸ê±´ ê·¸ë ‡ê³  ìš”ì¦˜ ê·¸ë˜í”„ê°€ ë„ˆë¬´ ë§ì´ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ë‹¤. CLASS 3, 4 ì—ì„œëŠ” ë¬¼ë¡ ì´ê³ , í•™êµ ë™ì•„ë¦¬ ì„¸ë¯¸ë‚˜ì—ì„œ ì¡°ì°¨ ê·¸ë˜í”„ê°€ ê³„ì† ë‚˜ì˜¨ë‹¤. ì•ìœ¼ë¡œ ë” ì§ˆë¦¬ë„ë¡ ë³´ê²Œë  ê²ƒ ê°™ë‹¤. ~~ì‚´ë ¤ì¤˜ ğŸ¥•ğŸ¥•ğŸ¥•ğŸ¥•ğŸ¥•~~

ì˜¤ëŠ˜ì˜ PSëŠ” ì—¬ê¸°ê¹Œì§€!

---
<a name="footnote_1">1</a>: <https://www.acmicpc.net/problem/1865>  