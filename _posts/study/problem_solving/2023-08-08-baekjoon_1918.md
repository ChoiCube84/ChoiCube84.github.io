---
layout: post
title: "백준 1918번"
subtitle: "후위 표기식"
date: 2023-08-08 23:40:00+0900
background: '/img/posts/2023/problem_solving/problem_solving.png'
katex: true
category: Study
tags: [ problem_solving ]
---

# 백준 1918번

오늘 풀어본 문제는 백준의 1918번 문제<sup>[1](#footnote_1)</sup>이다. 문제 풀이에 사용한 언어는 C++ 이다.

## solved.ac 기준 CLASS

<img src="https://static.solved.ac/class/c4.svg" width="50%" height="50%" alt="CLASS 4">

## 문제 정보

이 문제의 내용과 조건은 다음과 같다.

### 문제

수식은 일반적으로 3가지 표기법으로 표현할 수 있다. 연산자가 피연산자 가운데 위치하는 중위 표기법(일반적으로 우리가 쓰는 방법이다), 연산자가 피연산자 앞에 위치하는 전위 표기법(prefix notation), 연산자가 피연산자 뒤에 위치하는 후위 표기법(postfix notation)이 그것이다. 예를 들어 중위 표기법으로 표현된 $a+b$는 전위 표기법으로는 $+ab$이고, 후위 표기법으로는 $ab+$가 된다.

이 문제에서 우리가 다룰 표기법은 후위 표기법이다. 후위 표기법은 위에서 말한 법과 같이 연산자가 피연산자 뒤에 위치하는 방법이다. 이 방법의 장점은 다음과 같다. 우리가 흔히 쓰는 중위 표기식 같은 경우에는 덧셈과 곱셈의 우선순위에 차이가 있어 왼쪽부터 차례로 계산할 수 없지만 후위 표기식을 사용하면 순서를 적절히 조절하여 순서를 정해줄 수 있다. 또한 같은 방법으로 괄호 등도 필요 없게 된다. 예를 들어 $a + b * c$를 후위 표기식으로 바꾸면 $abc*+$가 된다.

중위 표기식을 후위 표기식으로 바꾸는 방법을 간단히 설명하면 이렇다. 우선 주어진 중위 표기식을 연산자의 우선순위에 따라 괄호로 묶어준다. 그런 다음에 괄호 안의 연산자를 괄호의 오른쪽으로 옮겨주면 된다.

예를 들어 $a+b * c$는 $(a+(b * c))$의 식과 같게 된다. 그 다음에 안에 있는 괄호의 연산자 $* $를 괄호 밖으로 꺼내게 되면 $(a+bc*)$가 된다. 마지막으로 또 $+$를 괄호의 오른쪽으로 고치면 $abc*+$가 되게 된다.

다른 예를 들어 그림으로 표현하면 $A+B*C-D/E$를 완전하게 괄호로 묶고 연산자를 이동시킬 장소를 표시하면 다음과 같이 된다.

<img src="https://upload.acmicpc.net/5aad2feb-d9fc-430a-954d-73a06ba0215f/-/preview/" width="50%" height="50%" alt="예시">

결과: $ABC*+DE/-$

이러한 사실을 알고 중위 표기식이 주어졌을 때 후위 표기식으로 고치는 프로그램을 작성하시오

### 입력

첫째 줄에 중위 표기식이 주어진다. 단 이 수식의 피연산자는 알파벳 대문자로 이루어지며 수식에서 한 번씩만 등장한다. 그리고 $-A+B$와 같이 $-$가 가장 앞에 오거나 $AB$와 같이 $* $가 생략되는 등의 수식은 주어지지 않는다. 표기식은 알파벳 대문자와 $+$, $-$, $*$, $/$, $($, $)$로만 이루어져 있으며, 길이는 $100$을 넘지 않는다. 

### 출력

첫째 줄에 후위 표기식으로 바뀐 식을 출력하시오

## 풀이과정

### 첫 번째 시도

후위 표기식이라는 개념을 처음 접헀기 때문에 초반에는 갈피를 잘 잡지 못했다. 그러다가 후위 표기식이 생긴 모양이 '안에서 바깥으로 펼치는 듯한 모양' 임을 알게되었다. 그리고 우선 순위가 낮은 연산자들은 식에서 먼저 등장하였다 하더라도, 후위 표기식에서는 밀린다는 것을 확인할 수 있었다.

이러한 점들을 고려한 결과 스택을 만들고 연산자에 따라 스택에 연산자를 넣거나 빼는 작업들을 수행하여 후위 표기식을 만들어야 한다는 것을 알게되었다.

코드는 다음과 같이 작성하였다.

```cpp
#include <bits/stdc++.h>

using namespace std;

int main(void) {
	ios::sync_with_stdio(0);
	cin.tie(0);

	string originalExpression;
	stringstream postfixNotation;

	char currentOperator;
	stack<char> operators;

	cin >> originalExpression;

	for (int i = 0; i < originalExpression.length(); i++) {
		char letter = originalExpression[i];

		if (letter == '+' || letter == '-') {
			if (!operators.empty()) {
				while (!operators.empty() && operators.top() != '(') {
					postfixNotation << operators.top();
					operators.pop();
				}
			}
			operators.push(letter);
		}
		else if (letter == '*' || letter == '/' || letter == '(') {
			operators.push(letter);
		}
		else if (letter == ')') {
			while (true) {
				currentOperator = operators.top();
				operators.pop();

				if (currentOperator == '(') {
					break;
				}
				else {
					postfixNotation << currentOperator;
				}
			}
		}
		else {
			postfixNotation << letter;
		}
	}

	while (!operators.empty()) {
		postfixNotation << operators.top();
		operators.pop();
	}

	cout << postfixNotation.str();

	return 0;
}
```

실행 결과 틀렸습니다 가 나왔다.

### 두 번째 시도

틀린 원인을 알아내보기 위해서 여러 가지 식을 직접 써보며 확인해 본 결과, 곱셈과 나눗셈 뿐만 아니라 덧셈 혹은 뺄셈이 스택에 이미 쌓여있을 때도 함께 출력한 뒤 제거해줘야 한다는 사실을 알게되었다.

코드는 다음과 같이 작성하였다.

```cpp
#include <bits/stdc++.h>

using namespace std;

int main(void) {
	ios::sync_with_stdio(0);
	cin.tie(0);

	string originalExpression;

	char currentOperator;
	stack<char> operators;

	cin >> originalExpression;

	for (int i = 0; i < originalExpression.length(); i++) {
		char letter = originalExpression[i];

		if (letter == '+' || letter == '-') {
			if (!operators.empty()) {
				while (!operators.empty() && operators.top() != '(') {
					cout << operators.top();
					operators.pop();
				}
			}
			operators.push(letter);
		}
		else if (letter == '*' || letter == '/') {
			while (!operators.empty() || (operators.top() == '*' || operators.top() == '/')) {
				cout << operators.top();
				operators.pop();
			}
			operators.push(letter);
		}
		else if (letter == '(') {
			operators.push(letter);
		}
		else if (letter == ')') {
			while (true) {
				currentOperator = operators.top();
				operators.pop();

				if (currentOperator == '(') {
					break;
				}
				else {
					cout << currentOperator;
				}
			}
		}
		else {
			cout << letter;
		}
	}

	while (!operators.empty()) {
		cout << operators.top();
		operators.pop();
	}

	return 0;
}
```

실행 결과 Segfault 런타임 에러가 발생하였다.

### 세 번째 시도

Segfault 가 발생한 원인은 아직 처리되지 않은 예외가 있기 때문이라고 생각하였고, 그래서 다시 다른 식들을 후위 표기식으로 바꿔보았다. 그러자, 곱셈과 나눗셈도 이미 스택에 있을 때 곱셈이나 나눗셈이 한번 더 와서는 안되고, 출력한 뒤 스택에서 제거해줘야 한다는 것을 알게되었다.

또한, 알고리즘이나 성공 여부에 중대한 영향을 미치는 것은 아니지만, 굳이 `std::stringstream` 을 사용하지 않고 바로 출력해도 문제가 없기 때문에 이 부분도 수정하였다.

코드는 다음과 같이 작성하였다.

```cpp
#include <bits/stdc++.h>

using namespace std;

int main(void) {
	ios::sync_with_stdio(0);
	cin.tie(0);

	string originalExpression;

	char currentOperator;
	stack<char> operators;

	cin >> originalExpression;

	for (int i = 0; i < originalExpression.length(); i++) {
		char letter = originalExpression[i];

		if (letter == '+' || letter == '-') {
			if (!operators.empty()) {
				while (!operators.empty() && operators.top() != '(') {
					cout << operators.top();
					operators.pop();
				}
			}
			operators.push(letter);
		}
		else if (letter == '*' || letter == '/') {
			while (!operators.empty() && (operators.top() == '*' || operators.top() == '/')) {
				cout << operators.top();
				operators.pop();
			}
			operators.push(letter);
		}
		else if (letter == '(') {
			operators.push(letter);
		}
		else if (letter == ')') {
			while (true) {
				currentOperator = operators.top();
				operators.pop();

				if (currentOperator == '(') {
					break;
				}
				else {
					cout << currentOperator;
				}
			}
		}
		else {
			cout << letter;
		}
	}

	while (!operators.empty()) {
		cout << operators.top();
		operators.pop();
	}

	return 0;
}
```

그러자 모든 테스트 케이스를 통과하고 정답이 나오는 것을 확인할 수 있었다.

## 마무리

후위 표기식을 정말 단어만 들어보고 실제로 접한 적은 없었기 때문에 어떻게 대처해야할 지 처음에 막막한 느낌이 들었다. 앞으로도 PS를 하다보면 듣도보도 못한 ~~듣보잡~~ 내용들이 더 나오게 될 텐데 조금 불안한 느낌이 든다.

간만에 스택을 이용하는 흥미로운 문제였다. 최근에는 죄다 BFS 문제만 풀다보니 큐는 자주 썼지만, 스택을 쓴 건 꽤 오랜만이였다. 이렇게 종종 잘 안쓰던 내용들이 다시 튀어나올지 모르는게 PS 아닌가 싶다.

오늘의 PS는 여기까지!

---
<a name="footnote_1">1</a>: <https://www.acmicpc.net/problem/1918>  