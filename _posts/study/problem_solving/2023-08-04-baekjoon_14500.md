---
layout: post
title: "백준 14500번"
subtitle: "테트로미노"
date: 2023-08-04 23:59:00+0900
background: '/img/posts/2023/problem_solving/problem_solving.png'
katex: true
category: Study
tags: [ problem_solving ]
---

# 백준 14500번

오늘 풀어본 문제는 백준의 14500번 문제<sup>[1](#footnote_1)</sup>이다. 문제 풀이에 사용한 언어는 C++ 이다.

## solved.ac 기준 CLASS

<img src="https://static.solved.ac/class/c3.svg" width="50%" height="50%" alt="CLASS 3">

## 문제 정보

이 문제의 내용과 조건은 다음과 같다.

### 문제

폴리오미노란 크기가 1×1인 정사각형을 여러 개 이어서 붙인 도형이며, 다음과 같은 조건을 만족해야 한다.

- 정사각형은 서로 겹치면 안 된다.
- 도형은 모두 연결되어 있어야 한다.
- 정사각형의 변끼리 연결되어 있어야 한다. 즉, 꼭짓점과 꼭짓점만 맞닿아 있으면 안 된다.

정사각형 4개를 이어 붙인 폴리오미노는 테트로미노라고 하며, 다음과 같은 5가지가 있다.

<img src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14500/1.png" width="50%" height="50%" alt="테트로미노">

아름이는 크기가 $N$×$M$인 종이 위에 테트로미노 하나를 놓으려고 한다. 종이는 1×1 크기의 칸으로 나누어져 있으며, 각각의 칸에는 정수가 하나 쓰여 있다.

테트로미노 하나를 적절히 놓아서 테트로미노가 놓인 칸에 쓰여 있는 수들의 합을 최대로 하는 프로그램을 작성하시오.

테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다.

### 입력

첫째 줄에 종이의 세로 크기 $N$과 가로 크기 $M$이 주어진다. ($4 \leq N, M \leq 500$)

둘째 줄부터 $N$개의 줄에 종이에 쓰여 있는 수가 주어진다. $i$번째 줄의 $j$번째 수는 위에서부터 $i$번째 칸, 왼쪽에서부터 $j$번째 칸에 쓰여 있는 수이다. 입력으로 주어지는 수는 $1,000$을 넘지 않는 자연수이다.

### 출력

첫째 줄에 테트로미노가 놓인 칸에 쓰인 수들의 합의 최댓값을 출력한다.

## 풀이과정

### 첫 번째 시도

처음에 문제를 봤을 때, 제한 시간이 2초인 것을 보고, 브루트 포스 기법을 써도 된다는 것 정도는 짐작할 수 있었다. 2초라고 해서 무조건 브루트 포스 기법을 쓸 수 있는 것은 아니지만, 가능한 칸의 개수가 비교적 적은 편이기 때문에 가능할 것이라고 생각했다.

브루트 포스 기법을 쓰는 것은 좋았는데, 처음에 떠올린 방법은 가능한 모든 도형을 '틀' 처럼 만들어서 모든 칸에다가 틀을 찍어서 계산하는 방식을 적용하여 최대값을 찾아내려 하였따. 그런데 구현할 방법이 딱히 떠오르지 안항 다른 방법을 사용하였다.

각 칸에서 DFS를 활용하여 최대 4칸까지 탐색하는 방법하도록 하여 값을 계산하고 비교하는 방식을 생각해보았다. 이 경우에, T자 모양 블럭은 그런 방식으로 찾을 수 있는 도형이 아니었기 때문에, 탐색 중간에 예외를 두어 미리 계산해두고 다른 탐색 결과값과 비교하도록 하였다.

코드는 다음과 같이 작성하였다.

```cpp
#include <bits/stdc++.h>

using namespace std;

int evaluateGrid(int searchDepth, int(*paper)[501], int height, int width, pair<int, int> gridPosition, pair<int, int> prevGridPosition, pair<int, int> prevOfPrevGridPosition);

int main(void) {
	ios::sync_with_stdio(0);
	cin.tie(0);

	int height, width, tempValue;
	int paper[501][501] = { 0, };
	int maximum = 0;

	cin >> height >> width;

	for (int i = 0; i < height; i++) {
		for (int j = 0; j < width; j++) {
			cin >> tempValue;
			paper[i][j] = tempValue;
		}
	}

	for (int i = 0; i < height; i++) {
		for (int j = 0; j < width; j++) {
			int tempValue = evaluateGrid(1, paper, height, width, { i , j }, { -100, -100 }, { -200, -200 });
			if (maximum < tempValue) {
				maximum = tempValue;
			}
		}
	}

	cout << maximum;

	return 0;
}

int evaluateGrid(int searchDepth, int(*paper)[501], int height, int width, pair<int, int> gridPosition, pair<int, int> prevGridPosition, pair<int, int> prevOfPrevGridPosition) {
	int result = 0;
	int up, down, left, right;

	if (gridPosition.first < 0 || gridPosition.first > height - 1 || gridPosition.second < 0 || gridPosition.second > width - 1) {
		return 0;
	}
	else if (gridPosition.first == prevOfPrevGridPosition.first && gridPosition.second == prevOfPrevGridPosition.second) {
		return 0;
	}

	else if (searchDepth < 4) {
		if (searchDepth == 2) {
			if (prevGridPosition.first == gridPosition.first) {
				if (gridPosition.first > 0 && gridPosition.first < height - 1) {
					result = (paper[gridPosition.first - 1][gridPosition.second] + paper[gridPosition.first + 1][gridPosition.second]);
				}
			}
			else if (prevGridPosition.second == gridPosition.second) {
				if (gridPosition.second > 0 && gridPosition.second < width - 1) {
					result = (paper[gridPosition.first][gridPosition.second - 1] + paper[gridPosition.first][gridPosition.second + 1]);
				}
			}
		}

		up = evaluateGrid(searchDepth + 1, paper, height, width, { gridPosition.first - 1, gridPosition.second }, gridPosition, prevGridPosition);
		down = evaluateGrid(searchDepth + 1, paper, height, width, { gridPosition.first + 1, gridPosition.second }, gridPosition, prevGridPosition);
		left = evaluateGrid(searchDepth + 1, paper, height, width, { gridPosition.first, gridPosition.second - 1 }, gridPosition, prevGridPosition);
		right = evaluateGrid(searchDepth + 1, paper, height, width, { gridPosition.first, gridPosition.second + 1 }, gridPosition, prevGridPosition);

		result = max({ result, up, down, left, right });

		return (result + paper[gridPosition.first][gridPosition.second]);
	}
	else {
		return paper[gridPosition.first][gridPosition.second];
	}
}
```

그러자 모든 테스트 케이스를 통과하고 정답이 나오는 것을 확인할 수 있었다.

## 마무리

(작성중)

오늘의 PS는 여기까지!

---
<a name="footnote_1">1</a>: <https://www.acmicpc.net/problem/14500>  